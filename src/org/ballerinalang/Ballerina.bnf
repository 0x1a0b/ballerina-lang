{

  classHeader='CopyrightHeader'
  parserClass="org.ballerinalang.parser.BallerinaParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Ballerina"
  psiImplClassSuffix="Impl"
  psiPackage="org.ballerinalang.psi"
  psiImplPackage="org.ballerinalang.psi.impl"

  elementTypeHolderClass="org.ballerinalang.psi.BallerinaTypes"
  elementTypeClass="org.ballerinalang.psi.BallerinaElementType"
  tokenTypeClass="org.ballerinalang.psi.BallerinaTokenType"

  tokens=[

      // ยง3.9 Ballerina keywords
      ACTION	      =	'action';
      BREAK	          =	'break';
      CATCH	          =	'catch';
      CONNECTOR	      =	'connector';
      CONST	          =	'const';
      ELSE	          =	'else';
      FORK	          =	'fork';
      FUNCTION	      =	'function';
      IF	          =	'if';
      IMPORT	      =	'import';
      ITERATE	      =	'iterate';
      JOIN	          =	'join';
      NEW	          =	'new';
      PACKAGE	      =	'package';
      REPLY	          =	'reply';
      RESOURCE	      =	'resource';
      RETURN	      =	'return';
      SERVICE	      =	'service';
      THROW	          =	'throw';
      THROWS	      =	'throws';
      TRY	          =	'try';
      TYPE	          =	'type';
      TYPECONVERTOR	  =	'typeconvertor';
      WHILE	          =	'while';
      WORKER	      =	'worker';
      BACKTICK        =   '`';
      VERSION         =   'version';
      PUBLIC          =   'public';
      ANY             =   'any';
      ALL             =   'all';
      AS              =   'as';
      TIMEOUT         =   'timeout';
      SENDARROW       =   '->';
      RECEIVEARROW    =   '<-';

      // ยง3.11 Separators
      LPAREN          = '(';
      RPAREN          = ')';
      LBRACE          = '{';
      RBRACE          = '}';
      LBRACK          = '[';
      RBRACK          = ']';
      SEMI            = ';';
      COMMA           = ',';
      DOT             = '.';

      // ยง3.12 Operators
      ASSIGN          = '=';
      GT              = '>';
      LT              = '<';
      BANG            = '!';
      TILDE           = '~';
      QUESTION        = '?';
      COLON           = ':';
      EQUAL           = '==';
      LE              = '<=';
      GE              = '>=';
      NOTEQUAL        = '!=';
      AND             = '&&';
      OR              = '||';
      ADD             = '+';
      SUB             = '-';
      MUL             = '*';
      DIV             = '/';
      BITAND          = '&';
      BITOR           = '|';
      CARET           = '^';
      MOD             = '%';
      DOLLAR_SIGN     = '$';
      AT              = '@';

      NullLiteral = "null"


      IntegerLiteral = "regexp:0|[1-9][0-9]*"

      FloatingPointLiteral = "regexp:(([0-9]+\.[0-9]*)|(\.[0-9]+)|([0-9]+))([eE][+-]?[0-9]+)?[fF]"

      BooleanLiteral="regexp:(true|false)"

      QuotedStringLiteral ='regexp:\"([^\\\"\r\n]|\\[^\r\n])*(\"|\\)?'

      ValidBackTickStringCharacters ='regexp:`[^`]*`'

      Identifier = "regexp:[a-zA-Z$_][a-zA-Z0-9$_]*"
//
      Letter =   "regexp:[a-zA-Z$_]"
//
      LetterOrDigit = "regexp:[a-zA-Z0-9$_]"

      WHITE_SPACE = 'regexp:[ \t\r\n\u000C]+'

      LINE_COMMENT = 'regexp://[^\r\n]*'



//      FloatLiteral  = "regexp:(([0-9]+\.[0-9]*)|(\.[0-9]+)|([0-9]+))([eE][+-]?[0-9]+)?[fF]"
//      DoubleLiteral =  "regexp:((([0-9]+\.[0-9]*)|(\.[0-9]+)|([0-9]+))([eE][+-]?[0-9]+)?"
//
//      FLit1    = ([0-9]+\.[0-9]*)
//      FLit2    = (\.[0-9]+)
//      FLit3    = ([0-9]+)
//      Exponent = ([eE][+-]?[0-9]+)
  ]
}

compilationUnit
    ::=   packageDeclaration?
        importDeclaration*
    (   serviceDefinition
    |   functionDefinition
    |   connectorDefinition
    |   structDefinition
    |   typeConvertorDefinition
    |   constantDefinition
    )+

packageDeclaration
    ::=   'package' packageName ';'

importDeclaration
    ::=   'import' packageName ('as' Identifier)? ';'

serviceDefinition
    ::=   annotation* 'service' Identifier serviceBody

serviceBody
    ::=   '{' serviceBodyDeclaration '}'

serviceBodyDeclaration
    ::=  connectorDeclaration* variableDeclaration* resourceDefinition+

resourceDefinition
    ::=   annotation* 'resource' Identifier '(' parameterList ')' functionBody

functionDefinition
    ::=   annotation* 'public'? 'function' Identifier '(' parameterList? ')' returnParameters? ('throws' Identifier)? functionBody

functionBody
    ::= '{' connectorDeclaration* variableDeclaration* workerDeclaration* statement+ '}'

connectorDefinition
    ::=   annotation* 'connector' Identifier '(' parameterList ')' connectorBody

connectorBody
    ::=   '{' connectorDeclaration* variableDeclaration* actionDefinition+ '}'

actionDefinition
    ::=   annotation* 'action' Identifier '(' parameterList ')' returnParameters?  ('throws' Identifier)? functionBody

connectorDeclaration
    ::=   qualifiedReference Identifier '=' 'new' qualifiedReference '(' expressionList? ')'';'

structDefinition
    ::=   'public'? 'type' Identifier structDefinitionBody

structDefinitionBody
    ::=   '{' (typeName Identifier ';')+ '}'

typeConvertorDefinition
    ::=   'typeconvertor' Identifier '(' typeConverterTypes Identifier ')' '('typeConverterTypes')' typeConvertorBody

typeConvertorBody
    ::=   '{' variableDeclaration* statement+ '}'

constantDefinition
    ::=   'const' typeName Identifier '=' literalValue ';'

variableDeclaration
    ::=   typeName Identifier ';'

// typeName below is only 'message' type
workerDeclaration
    ::=   'worker' Identifier '(' typeName Identifier ')'  '{' variableDeclaration* statement+ '}'

returnParameters
    ::= '(' (namedParameterList | returnTypeList) ')'

namedParameterList
    ::=   namedParameter (',' namedParameter)*

namedParameter
    ::=   typeName Identifier

returnTypeList
    ::=   typeName (',' typeName)*

qualifiedTypeName
    ::=   packageName ':' unqualifiedTypeName

typeConverterTypes
    ::=   simpleType
    |   withFullSchemaType
    |   withSchemaIdType
    |   withScheamURLType

unqualifiedTypeName
    ::=   simpleTypeArray
    |   simpleTypeIterate
    |   withFullSchemaType
    |   withFullSchemaTypeArray
    |   withFullSchemaTypeIterate
    |   withScheamURLType
    |   withSchemaURLTypeArray
    |   withSchemaURLTypeIterate
    |   withSchemaIdType
    |   withScheamIdTypeArray
    |   withScheamIdTypeIterate
    |   simpleType

simpleType
    ::=   Identifier

simpleTypeArray
    ::=   Identifier '[' ']'//todo

simpleTypeIterate
    ::= Identifier '~'

withFullSchemaType
	::=	Identifier '<' '{' QuotedStringLiteral '}' Identifier '>'

withFullSchemaTypeArray
	::=	Identifier '<' '{' QuotedStringLiteral '}' Identifier '>' '[' ']'//todo

withFullSchemaTypeIterate
	::=	Identifier '<' '{' QuotedStringLiteral '}' Identifier '>' '~'

withScheamURLType
	::=	Identifier '<' '{' QuotedStringLiteral '}' '>'

withSchemaURLTypeArray
	::=	Identifier '<' '{' QuotedStringLiteral '}' '>' '[' ']'//todo

withSchemaURLTypeIterate
	::=	Identifier '<' '{' QuotedStringLiteral '}' '>' '~'

withSchemaIdType
	::=	Identifier '<' Identifier '>'

withScheamIdTypeArray
	::=	Identifier '<' Identifier '>' '[' ']' //todo

withScheamIdTypeIterate
	::=	Identifier '<' Identifier '>' '~'

typeName
    ::=   unqualifiedTypeName
    |   qualifiedTypeName

qualifiedReference
    ::=   packageName ':' Identifier

parameterList
    ::=   parameter  (',' parameter )*

parameter
    ::=   annotation* typeName Identifier

packageName
    ::=   Identifier ('.' Identifier)*

literalValue
    ::=   IntegerLiteral
    |   FloatingPointLiteral
    |   QuotedStringLiteral
    |   BooleanLiteral
    |   NullLiteral

 //============================================================================================================
 // ANNOTATIONS

 annotation
     ::=   '@' annotationName ( '(' ( elementValuePairs | elementValue )? ')' )?

 annotationName ::= Identifier

 elementValuePairs
     ::=   elementValuePair (',' elementValuePair)*

 elementValuePair
     ::=    Identifier '=' elementValue

 elementValue
     ::=   expression
     |   annotation
     |   elementValueArrayInitializer

 elementValueArrayInitializer
     ::=   '{' (elementValue (',' elementValue)*)? (',')? '}'

 //============================================================================================================
// STATEMENTS / BLOCKS

statement
    ::=   functionInvocationStatement
    |   ifElseStatement
    |   iterateStatement
    |   whileStatement
    |   breakStatement
    |   forkJoinStatement
    |   tryCatchStatement
    |   throwStatement
    |   returnStatement
    |   replyStatement
    |   workerInteractionStatement
    |   commentStatement
    |   actionInvocationStatement
    |   assignmentStatement

assignmentStatement
    ::=   variableReferenceList '=' expression ';'

variableReferenceList
    ::=   variableReference (',' variableReference)*

ifElseStatement
    ::=   'if' '(' expression ')' '{' statement* '}' elseIfClause* elseClause?

elseIfClause
    ::=   'else' 'if' '(' expression ')' '{' statement* '}'

elseClause
    ::=   'else' '{' statement*'}'

iterateStatement
    ::=   'iterate' '(' typeName Identifier ':' expression ')' '{' statement+ '}'

whileStatement
    ::=   'while' '(' expression ')' '{' statement+ '}'

breakStatement
    ::=   'break' ';'

// typeName is only message
forkJoinStatement
    ::=   'fork' '(' typeName Identifier ')' '{' workerDeclaration+ '}' joinClause? timeoutClause?

// below typeName is only 'message[]'
joinClause
    ::=   'join' '(' joinConditions ')' '(' typeName Identifier ')'  '{' statement+ '}'

joinConditions
    ::=   'any' IntegerLiteral (Identifier (',' Identifier)*)?
    |   'all' (Identifier (',' Identifier)*)?

// below typeName is only 'message[]'
timeoutClause
    ::=   'timeout' '(' expression ')' '(' typeName Identifier ')'  '{' statement+ '}'

tryCatchStatement
    ::=   'try' '{' statement+ '}' catchClause

// below tyeName is only 'exception'
catchClause
    ::=   'catch' '(' typeName Identifier ')' '{' statement+ '}'

throwStatement
    ::=   'throw' expression ';'

returnStatement
    ::=   'return' expressionList? ';'

// below Identifier is only a type of 'message'
replyStatement
    ::=   'reply' expression ';'

workerInteractionStatement
    ::=   triggerWorker
    |   workerReply

// below left Identifier is of type 'message' and the right Identifier is of type 'worker'
triggerWorker
    ::=   Identifier '->' Identifier ';'

// below left Identifier is of type 'worker' and the right Identifier is of type 'message'
workerReply
    ::=   Identifier '<-' Identifier ';'

commentStatement
    ::=   LINE_COMMENT

actionInvocationStatement
    ::=   actionInvocation argumentList ';'

//todo: fix left recursion here
variableReference
    ::=   Identifier '['expression']'                 // mapArrayVariableIdentifier// array and map reference
//    |   variableReference ('.' variableReference)+  // structFieldIdentifier// struct field reference
          |      Identifier                                // simpleVariableIdentifier// simple identifier
argumentList
    ::=   '(' expressionList? ')'

expressionList
    ::=   expression (',' expression)*

functionInvocationStatement
    ::=   functionName argumentList ';'

functionName
    ::=   (packageName ':')? Identifier

actionInvocation
    ::=   packageName ':' Identifier '.' Identifier

backtickString
   ::=     ValidBackTickStringCharacters


// 1 ------------------------------------------
//
////todo 23/01/2017: This was introduce to prevent left recursion
//private basicExpression::=
//         functionName argumentList                                         // functionInvocationExpression
//    |   backtickString                                                      // templateExpression
//    |   actionInvocation argumentList                                       // actionInvocationExpression
//    |   '[' expressionList ']'                                              // arrayInitializerExpression
//    |   '{' mapInitKeyValueList '}'                                         // mapInitializerExpression
//    |   'new' (packageName ':' )? Identifier ('(' expressionList? ')')?     // structInitializeExpression
//    |    literalValue                                                       // literalExpression
//    |   variableReference                                                   // variableReferenceExpression
//    |   basicExpression_
//
//basicExpression_ ::=
//'(' typeName ')' basicExpression
// |   ('+'|'-'|'!') basicExpression
//|   '(' basicExpression ')'
//  |   basicExpression ('^') basicExpression
//
//
//expression
//    ::=
//       '(' typeName ')' basicExpression                                         // typeCastingExpression
//    |   ('+'|'-'|'!') basicExpression                                            // unaryExpression
//    |   '(' basicExpression ')'                                                  // bracedExpression
//    |   basicExpression ('^') basicExpression                                         // binaryPowExpression
//    |   basicExpression ('/') basicExpression                                         // binaryDivisionExpression
//    |   basicExpression ('*') basicExpression                                         // binaryMultiplicationExpression
//    |   basicExpression ('%') basicExpression                                         // binaryModExpression
//    |   basicExpression ('&&') basicExpression                                        // binaryAndExpression
//    |   basicExpression ('+') basicExpression                                         // binaryAddExpression
//    |   basicExpression ('-') basicExpression                                         // binarySubExpression
//    |   basicExpression ('||') basicExpression                                        // binaryOrExpression
//    |   basicExpression ('>') basicExpression                                         // binaryGTExpression
//    |   basicExpression ('>=') basicExpression                                        // binaryGEExpression
//    |   basicExpression ('<') basicExpression                                         // binaryLTExpression
//    |   basicExpression ('<=') basicExpression                                        // binaryLEExpression
//    |   basicExpression ('==') basicExpression                                        // binaryEqualExpression
//    |   basicExpression ('!=') basicExpression                                        // binaryNotEqualExpression
//    |   basicExpression
//

//2--------------------------------------
//  simpleExpression
//      ::=
//               functionName argumentList                                           // functionInvocationExpression
//
//      |   backtickString                                                      // templateExpression
//      |   actionInvocation argumentList                                       // actionInvocationExpression
//      |   '[' expressionList ']'                                              // arrayInitializerExpression
//      |   '{' mapInitKeyValueList '}'                                         // mapInitializerExpression
//      |   'new' (packageName ':' )? Identifier ('(' expressionList? ')')?     // structInitializeExpression
//      |   literalValue                                                        // literalExpression
//      |   variableReference                                                    // variableReferenceExpression
//
//   expression::=    ('(' typeName ')' simpleExpression+ )  |   (('+'|'-'|'!') simpleExpression+)   |   ('(' simpleExpression+ ')') | (simpleExpression+ ('^' | '/' | '*' | '%' | '&&' | '+' | '-' | '||' | '>' | '>='| '<' | '<=' | '==' | '!='| simpleExpression) simpleExpression+ )
//
//
//
//
////basicExpression::=
////        backtickString                                                      // templateExpression
////    |   functionName argumentList                                           // functionInvocationExpression
////    |   actionInvocation argumentList                                       // actionInvocationExpression
////    |   '[' expressionList ']'                                              // arrayInitializerExpression
////    |   '{' mapInitKeyValueList '}'                                         // mapInitializerExpression
////    |   'new' (packageName ':' )? Identifier ('(' expressionList? ')')?     // structInitializeExpression
////    |    literalValue                                                        // literalExpression
////    |   variableReference                                                   // variableReferenceExpression

// 3 ---------------------------------------


//expression::=
//
//       '(' typeName ')' basicExpression                                         // typeCastingExpression
//    |   ('+'|'-'|'!') basicExpression                                            // unaryExpression
//    |   '(' basicExpression ')'                                                  // bracedExpression
//    |   basicExpression ('^') basicExpression                                         // binaryPowExpression
//    |   basicExpression ('/') basicExpression                                         // binaryDivisionExpression
//    |   basicExpression ('*') basicExpression                                         // binaryMultiplicationExpression
//    |   basicExpression ('%') basicExpression                                         // binaryModExpression
//    |   basicExpression ('&&') basicExpression                                        // binaryAndExpression
//    |   basicExpression ('+') basicExpression                                         // binaryAddExpression
//    |   basicExpression ('-') basicExpression                                         // binarySubExpression
//    |   basicExpression ('||') basicExpression                                        // binaryOrExpression
//    |   basicExpression ('>') basicExpression                                         // binaryGTExpression
//    |   basicExpression ('>=') basicExpression                                        // binaryGEExpression
//    |   basicExpression ('<') basicExpression                                         // binaryLTExpression
//    |   basicExpression ('<=') basicExpression                                        // binaryLEExpression
//    |   basicExpression ('==') basicExpression                                        // binaryEqualExpression
//    |   basicExpression ('!=') basicExpression                                        // binaryNotEqualExpression
//    |   basicExpression
//
//
//
//basicExpression::=
//        backtickString                                                      // templateExpression
//    |   functionName argumentList                                           // functionInvocationExpression
//    |   actionInvocation argumentList                                       // actionInvocationExpression
//    |   '[' expressionList ']'                                              // arrayInitializerExpression
//    |   '{' mapInitKeyValueList '}'                                         // mapInitializerExpression
//    |   'new' (packageName ':' )? Identifier ('(' expressionList? ')')?     // structInitializeExpression
//    |    literalValue                                                        // literalExpression
//    |   variableReference                                                   // variableReferenceExpression

// 4 ---------------------------

expression::=
       '(' typeName ')' basicExpression
    |   ('+'|'-'|'!') basicExpression
    |   '(' basicExpression ')'
    |   basicExpression (('^' | '/' | '*' | '%' | '&&' | '+' | '-' | '||' | '>' | '>='| '<' | '<=' | '==' | '!=') basicExpression ) *

private basicExpression::=
        backtickString                                                      // templateExpression
    |   functionName argumentList                                           // functionInvocationExpression
    |   actionInvocation argumentList                                       // actionInvocationExpression
    |   '[' expressionList ']'                                              // arrayInitializerExpression
    |   '{' mapInitKeyValueList '}'                                         // mapInitializerExpression
    |   'new' (packageName ':' )? Identifier ('(' expressionList? ')')?     // structInitializeExpression
    |    literalValue                                                        // literalExpression
    |   variableReference
    |   '(' typeName ')' basicExpression
    |   ('+'|'-'|'!') basicExpression
    |   '(' basicExpression ')'

mapInitKeyValueList
    ::=   mapInitKeyValue (',' mapInitKeyValue)*

mapInitKeyValue
    ::=   QuotedStringLiteral ':' expression

NullLiteral
    ::=   'null'
